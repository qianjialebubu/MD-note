# java设计模式

## 一、七大原则

### 依赖倒置原则





## 二、设计模式

### 代理模式

#### 静态代理

#### 动态代理

##### JDK动态代理

##### CGLib动态代理



### 单例模式

> 应用:Bean默认为单例模式,runtime函数也是单例模式

#### 八种单例模式

- 饿汉式一
- 饿汉式二
- 懒汉式一
- 懒汉式二
- 懒汉式三
- 双重检查
- 枚举
- 静态内部类

### 工厂模式

将实例化对象的方法提取出来。使用一个工厂类来进行维护和管理。其他需要实现类的对象直接通过工厂类进行调用。进行依赖的解耦。尽量依赖抽象的原则。

> Spring使用工厂模式，通过BeanFactory和ApplicationContext来创建对象

#### 简单工厂模式

#### 工厂方法模式

#### 抽象工厂模式







### 策略模式

> 分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为的变化独立于算法的使用者。将可能会产生变化的部分分离封装成接口。例如鸭子种类问题：将飞行的属性（可能会改变）封装成接口，使用不同的子类进行实例化。在具体调用时只需要将不同的子类对象进行传入即可。

> -  策略模式的关键是：**分析项目中变化部分与不变部分**。其中鸭子的属性是变化的部分，实际使用的是不变的部分。
> - 策略模式的核心思想是：多用组合/聚合 少用继承；用行为类组合，而不是行为的继承。更有弹性
> - 体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为）即可，避免了使用多重转移语句（if..else if..else)
> -  提供了可以替换继承关系的办法： 策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展
> -  需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大。





### 模板方法

> 把类似业务的相同部分提取出来写到一起，把不同的部分进行在子类进行实例化。精简开发。模板方法设置为final，可以防止子类进行重写。
>
> - 钩子方法：设置一个布尔值进行返回，实现对某一个方法的控制是否使用。如果子类不使用该方法，设置该布尔值为false。