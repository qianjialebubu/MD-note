# java设计模式

## 一、七大原则

### 依赖倒置原则





## 二、设计模式

### 代理模式

#### 静态代理

#### 动态代理

##### JDK动态代理

##### CGLib动态代理



### 单例模式

> 应用:Bean默认为单例模式,runtime函数也是单例模式

#### 八种单例模式

- 饿汉式一
- 饿汉式二
- 懒汉式一
- 懒汉式二
- 懒汉式三
- 双重检查
- 枚举
- 静态内部类

### 工厂模式

将实例化对象的方法提取出来。使用一个工厂类来进行维护和管理。其他需要实现类的对象直接通过工厂类进行调用。进行依赖的解耦。尽量依赖抽象的原则。

> Spring使用工厂模式，通过BeanFactory和ApplicationContext来创建对象

#### 简单工厂模式

#### 工厂方法模式

#### 抽象工厂模式







### 策略模式

> 分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为的变化独立于算法的使用者。将可能会产生变化的部分分离封装成接口。例如鸭子种类问题：将飞行的属性（可能会改变）封装成接口，使用不同的子类进行实例化。在具体调用时只需要将不同的子类对象进行传入即可。

> -  策略模式的关键是：**分析项目中变化部分与不变部分**。其中鸭子的属性是变化的部分，实际使用的是不变的部分。
> - 策略模式的核心思想是：多用组合/聚合 少用继承；用行为类组合，而不是行为的继承。更有弹性
> - 体现了“对修改关闭，对扩展开放”原则，客户端增加行为不用修改原有代码，只要添加一种策略（或者行为）即可，避免了使用多重转移语句（if..else if..else)
> -  提供了可以替换继承关系的办法： 策略模式将算法封装在独立的Strategy类中使得你可以独立于其Context改变它，使它易于切换、易于理解、易于扩展
> -  需要注意的是：每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大。





### 模板方法

> 把类似业务的相同部分提取出来写到一起，把不同的部分进行在子类进行实例化。精简开发。模板方法设置为final，可以防止子类进行重写。
>
> - 钩子方法：设置一个布尔值进行返回，实现对某一个方法的控制是否使用。如果子类不使用该方法，设置该布尔值为false。





### 适配器模式

适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)、

结构型的模式

类适配器

> 1. Java是单继承机制，所以类适配器需要继承src类这一点算是一个缺点, 因为这要求dst(目标对象)必须是接口，有一定局限性;目标对象需要是接口.
> 2. 适配类需要继承src类以及实现dst接口
> 3. src类的方法在Adapter中都会暴露出来，也增加了使用的成本。
> 4. 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了

对象适配器

> 修改adapter类,不再是继承src类,而是持有src类的实例化,同时需要实现dst接口.<br>
>
> 与类适配器不同的是,对象适配器使用的是组合代替继承,解决了类适配器必须继承src的局限性的问题.

接口适配器

> 当不需要全部实现接口提供的方法时，**可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求.**
>
> 适用一个不是接口的所有方法都需要实现的情况.

1. 三种命名方式，是根据 src是以怎样的形式给到Adapter（在Adapter里的形式）来命名的。
2. 类适配器：以类给到，在Adapter里，就是将src当做类，继承
3. 对象适配器：以对象给到，在Adapter里，将src作为一个对象，持有
4. 接口适配器：以接口给到，在Adapter里，将src作为一个接口，实现
5. Adapter模式最大的作用还是将原本不兼容的接口融合在一起工作。
6. 实际开发中，实现起来不拘泥于我们讲解的三种经典形式



### 桥接模式



观察者模式